---
layout: page
title: leetcode 1625. Lexicographically Smallest String After Applying Operations
permalink: /s1625-java
---
[Leetcode 1625. Lexicographically Smallest String After Applying Operations](https://algoadvance.github.io/algoadvance/l1625)
### Problem Statement

Given a string `s` of even length consisting of digits from `0` to `9`, two types of operations can be performed on it:

1. **Add**: Choose an integer `a` and add `a` to all odd-indexed digits of the string (0-based). Note that the value of each digit in the string must be in the range `0` to `9`. Addition is done modulo `10`.
2. **Rotate**: Choose an integer `b` and rotate the string `s` to the right by `b` positions.

The objective is to return the lexicographically smallest string that can be obtained by applying the above operations any number of times in any order.

### Clarifying Questions
1. **Constraints on `a` and `b`**: Given integers `a` and `b`, are there any constraints on their values?
    - **Answer**: There are no specific constraints mentioned for the values of `a` and `b` outside the operations described.

2. **Initial String `s`**: Is `s` guaranteed to be non-empty and of even length?
    - **Answer**: Yes, `s` is guaranteed to be of even length and non-empty.

3. **Operation Frequency**: Can the operations be applied any number of times, including zero?
   - **Answer**: Yes, operations can be applied any number of times in any order.

### Strategy

We need to explore the possible strings that can be generated by performing the operations and keep track of the smallest possible lexicographical string encountered.

1. **Breadth-First Search (BFS)**: Use BFS to explore all possible strings. This method ensures that we can systematically explore all transformations while keeping track of the minimum lexicographical string.
2. **Visited Strings**: Store all visited strings to avoid recomputation and infinite loops.
3. **Initial Setup**: Start with the initial string and perform the operations while updating the smallest string found.

### Code

```java
import java.util.*;

public class LexicographicallySmallestString {
    public String findLexSmallestString(String s, int a, int b) {
        Queue<String> queue = new LinkedList<>();
        Set<String> visited = new HashSet<>();
        queue.offer(s);
        visited.add(s);
        String minString = s;

        while (!queue.isEmpty()) {
            String cur = queue.poll();
            
            // Try the addition operation
            String addStr = addOperation(cur, a);
            if (!visited.contains(addStr)) {
                visited.add(addStr);
                queue.offer(addStr);
                if (addStr.compareTo(minString) < 0) {
                    minString = addStr;
                }
            }

            // Try the rotation operation
            String rotateStr = rotateOperation(cur, b);
            if (!visited.contains(rotateStr)) {
                visited.add(rotateStr);
                queue.offer(rotateStr);
                if (rotateStr.compareTo(minString) < 0) {
                    minString = rotateStr;
                }
            }
        }

        return minString;
    }

    private String addOperation(String s, int a) {
        char[] chars = s.toCharArray();
        for (int i = 1; i < s.length(); i += 2) {
            int digit = (chars[i] - '0' + a) % 10;
            chars[i] = (char) (digit + '0');
        }
        return new String(chars);
    }

    private String rotateOperation(String s, int b) {
        int n = s.length();
        b = b % n;  // Just in case b is greater than length of s
        return s.substring(n - b) + s.substring(0, n - b);
    }

    public static void main(String[] args) {
        LexicographicallySmallestString solver = new LexicographicallySmallestString();
        String s = "5525";
        int a = 9;
        int b = 2;
        System.out.println(solver.findLexSmallestString(s, a, b));  // Example usage
    }
}
```

### Time Complexity

1. **BFS Exploration**: The time complexity to explore all possible strings is O(n * 10^n), where `n` is the length of the string. Each digit position can exist in one of 10 states (0-9), and BFS explores these while keeping track of unique transformations.

2. **String Comparisons**: Each string comparison and string operations (like substring and concatenation) take O(n).

Considering practical constraints and execution limits, this approach efficiently covers the required transformations within feasible limits.


### Cut your prep time in half and DOMINATE your interview with [AlgoAdvance AI](https://algoAdvance.com)

- Got blindsided by a question you didn't expect?

- Spend too much time studying?

- Or simply don't have the time to go over all 3000 questions?

