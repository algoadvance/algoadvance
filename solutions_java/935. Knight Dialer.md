---
layout: page
title: leetcode 935. Knight Dialer
permalink: /s935-java
---
[Leetcode 935. Knight Dialer full problem statement](https://algoadvance.github.io/algoadvance/l935)
### Problem Statement

The problem is from LeetCode and is described as follows:

The chess knight has a unique movement, defined by the L-shape: it may move two squares horizontally and one square vertically, or two squares vertically and one square horizontally. The knight can move to any of its 8 possible moves from a given square, provided the destination square is on a standard 3x3 phone keypad grid (1-9 and 0):

```
1 2 3
4 5 6
7 8 9
  0
```

Given an integer `n`, return how many distinct phone numbers of length `n` we can dial.

You are allowed to place the knight on any of the numbers and then make `n-1` hops. A sequence of hops that visits the same number more than once is allowed.

### Clarifying Questions

1. **Q:** Can the knight start at any position on the keypad?
   - **A:** Yes, the knight can start from any digit on the keypad.
   
2. **Q:** Do we need to consider invalid positions (e.g., moving into a negative index)?
   - **A:** No, moves that lead to invalid positions arenâ€™t considered.

3. **Q:** What are the constraints on `n`?
   - **A:** Typically the constraints will be provided but you can assume that `n` is at most 5000 for the purpose of this problem.

### Strategy

1. **Representation:** Use a list to represent possible moves from each digit. For instance, from `1`, the possible digits that can be reached are `6` and `8`.
2. **DP Table:** Use dynamic programming to store the number of ways to reach each digit after a certain number of hops.
3. **Initialization:** Initialize the table for hop count 1 (i.e., directly starting positions).
4. **Transition:** Use the DP transition to build up the table to `n` hops.
5. **Summation:** Sum up the values for `n` hops across all starting positions.

### Code

```java
public class KnightDialer {

    // Possible moves a knight can make from each digit
    private static final int[][] moves = {
        {4, 6},    // Moves from 0
        {6, 8},    // Moves from 1
        {7, 9},    // Moves from 2
        {4, 8},    // Moves from 3
        {3, 9, 0}, // Moves from 4
        {},        // Moves from 5 (no moves possible as per knight's movement on knight pads)
        {1, 7, 0}, // Moves from 6
        {2, 6},    // Moves from 7
        {1, 3},    // Moves from 8
        {2, 4}     // Moves from 9
    };
    
    public int knightDialer(int n) {
        int MOD = 1_000_000_007; // To prevent overflow issues
        
        // DP array, dp[i][j] is the count of distinct numbers at the j-th digit with i hops
        int[][] dp = new int[n + 1][10];
        
        // Base case: with 1 hop, each number can dial itself
        for (int i = 0; i <= 9; i++) {
            dp[1][i] = 1;
        }
        
        // Fill DP table
        for (int hop = 2; hop <= n; hop++) {
            for (int num = 0; num <= 9; num++) {
                dp[hop][num] = 0;
                for (int move : moves[num]) {
                    dp[hop][num] = (dp[hop][num] + dp[hop - 1][move]) % MOD;
                }
            }
        }
        
        // Collecting results for all starting positions
        int result = 0;
        for (int i = 0; i <= 9; i++) {
            result = (result + dp[n][i]) % MOD;
        }
        
        return result;
    }

    public static void main(String[] args) {
        KnightDialer kd = new KnightDialer();
        System.out.println(kd.knightDialer(1)); // expect 10
        System.out.println(kd.knightDialer(2)); // expect 20
        System.out.println(kd.knightDialer(3)); // expect 46
    }
}
```

### Time Complexity

The time complexity of this solution is \(O(n \times 10 \times k)\), where `n` is the input length and `k` is the typical number of moves (which is constant and at most 8). Therefore, it simplifies to \(O(n)\) for practical purposes. The space complexity is \(O(n \times 10)\), which simplifies to \(O(n)\).