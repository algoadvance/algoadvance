---
layout: page
title: leetcode 924. Minimize Malware Spread
permalink: /s924-java
---
[Leetcode 924. Minimize Malware Spread](https://algoadvance.github.io/algoadvance/l924)
### Problem Statement
In a network of nodes, each node represents a different computer, and each edge between two nodes represents a direct connection between those two computers. Some nodes are initially infected by malware. Whenever two directly connected nodes are infected, the malware spread to both nodes. The goal is to find the node such that if we remove it from the network, the total number of nodes infected by the malware (after the initial spread) will be minimized. If there are multiple solutions, return the node with the smallest index.

#### Example:
- **Input:**
  ```java
  int[][] graph = {{1,1,0},{1,1,0},{0,0,1}};
  int[] initial = {0,1};
  ```
- **Output:**
  ```java
  0
  ```

### Clarifying Questions
1. **Is the graph always connected?**
   - No, the graph can consist of multiple disconnected components.
2. **Can multiple nodes be infected initially?**
   - Yes, the `initial` array can contain multiple nodes.
3. **How should ties be handled?**
   - If multiple nodes result in the same minimized infection spread, return the node with the smallest index.

### Strategy
1. **Graph Representation:** Use an adjacency matrix for the graph. The `graph[i][j]` will be `1` if there is a direct connection.
2. **DFS/BFS Traversal:** We need to simulate the spread of the malware to determine how removing one node affects the overall infection spread.
3. **Count Components and Infections:** For each node in `initial`, consider it removed, and then calculate the size of newly infected components.
4. **Choose Optimal Removal:** Select the node whose removal minimizes the spread, with ties resolved by choosing the node with the smallest index.

### Code
Here's a solution implemented in Java:

```java
import java.util.*;

public class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        Arrays.sort(initial);
        
        int[] infectedBy = new int[n];
        for(int node : initial) {
            boolean[] visited = new boolean[n];
            dfs(graph, visited, node, node, infectedBy);
        }
        
        int[] spreadCount = new int[n];
        for (int i = 0; i < n; i++) {
            if (infectedBy[i] != -1) {
                spreadCount[infectedBy[i]]++;
            }
        }
        
        int minNode = initial[0];
        int minSpread = Integer.MAX_VALUE;
        
        for (int node : initial) {
            int spread = 0;
            for (int i = 0; i < n; i++) {
                if (infectedBy[i] != node && graph[node][i] == 1) {
                    spread++;
                }
            }
            if (spread < minSpread || (spread == minSpread && node < minNode)) {
                minSpread = spread;
                minNode = node;
            }
        }
        
        return minNode;
    }

    private void dfs(int[][] graph, boolean[] visited, int curr, int infectingNode, int[] infectedBy) {
        if (visited[curr]) {
            return;
        }
        visited[curr] = true;
        if (infectedBy[curr] == 0) {
            infectedBy[curr] = infectingNode;
        } else if (infectedBy[curr] != infectingNode) {
            infectedBy[curr] = -1;
        }
        
        for (int next = 0; next < graph.length; next++) {
            if (graph[curr][next] == 1) {
                dfs(graph, visited, next, infectingNode, infectedBy);
            }
        }
    }
}
```

### Time Complexity
1. **DFS Traversals:** 
   - Each node can at most traverse `O(V + E)` times collectively, where `V` is the number of vertices and `E` is the number of edges. So it can be approximated to `O(V^2)`.
2. **Sorting the Initial Array:** 
   - Sorting takes `O(k log k)` where `k` is the length of the initial array.
   
The overall complexity is `O(V^2 + k log k)` where `V` is the number of nodes, and `k` is the number of initially infected nodes.


### Cut your prep time in half and DOMINATE your interview with [AlgoAdvance AI](https://algoAdvance.com)

- Got blindsided by a question you didn't expect?

- Spend too much time studying?

- Or simply don't have the time to go over all 3000 questions?

