---
layout: page
title: leetcode 1300. Sum of Mutated Array Closest to Target
permalink: /s1300-java
---
[Leetcode 1300. Sum of Mutated Array Closest to Target](https://algoadvance.github.io/algoadvance/l1300)
### Problem Statement

**1300. Sum of Mutated Array Closest to Target**

Given an integer array `arr` and a target value `target`, we need to find an integer such that when we change all the integers larger than that element in the array to be equal to that element, the sum of the array gets as close as possible to `target`.

Here is the specific problem statement:
- You are given an integer array `arr` and an integer `target`.
- Replace all elements in the array `arr` that are greater than a certain integer `value` with `value`.
- Find a `value` such that the sum of the array is closest to `target`.

### Clarifying Questions
1. **Input Constraints:**
   - What are the constraints on the array size (`n`) and the values within the array?
   - What is the range of `target`?

2. **Output:**
   - Should the function return the closest possible `value` whose sum is as close as possible to `target`?

Letâ€™s move forward assuming the following common constraints:
- `1 <= arr.length <= 10^4`
- `0 <= arr[i], target <= 10^6`

### Strategy
To solve this problem, we'll use a binary search approach:
1. **Sorting:**
   - First, sort the array `arr`.

2. **Binary Search:**
   - Initialize `l` to 0 and `r` to the maximum value in the array or `target` if the maximum value exceeds the target.
   - Perform binary search to find the `value` making the sum of the mutated array closest to `target`.

3. **Helper Function:**
   - Create a helper function `getMutatedSum(int[] arr, int value)` that returns the sum of the array after mutating values greater than `value`.

4. **Determine the Closest Criteria:**
   - Evaluate the sums generated by the mid-values in the binary search and adjust the boundaries accordingly until the closest possible sum to `target` is found.

### Code

```java
import java.util.Arrays;

public class ClosestSum {

    public int findBestValue(int[] arr, int target) {
        Arrays.sort(arr);
        int l = 0, r = arr[arr.length - 1];
        int result = 0;
        int minDiff = Integer.MAX_VALUE;

        while (l <= r) {
            int mid = l + (l - r) / 2;
            int sum = getMutatedSum(arr, mid);
            int diff = Math.abs(sum - target);

            if (diff < minDiff) {
                minDiff = diff;
                result = mid;
            } else if (diff == minDiff) {
                result = Math.min(result, mid);
            }

            if (sum < target) {
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        return result;
    }

    private int getMutatedSum(int[] arr, int value) {
        int sum = 0;
        for (int num : arr) {
            sum += Math.min(num, value);
        }
        return sum;
    }

    public static void main(String[] args) {
        ClosestSum cs = new ClosestSum();
        int[] arr = {4, 9, 3};
        int target = 10;
        System.out.println(cs.findBestValue(arr, target)); // Output: expected value
    }
}
```

### Time Complexity
- **Sorting the array:** O(n log n)
- **Binary Search:** O(log(max(arr)) * n), where `max(arr)` is the maximum value in the array.
- **Total Complexity:** O(n log n + log(max(arr)) * n). This is efficient given the size constraints.

If there are any uncertainties, here is the step-by-step breakdown of the approach and the code should yield the optimal `value` configuration to get the sum closest to `target`.


### Cut your prep time in half and DOMINATE your interview with [AlgoAdvance AI](https://algoAdvance.com)

- Got blindsided by a question you didn't expect?

- Spend too much time studying?

- Or simply don't have the time to go over all 3000 questions?

