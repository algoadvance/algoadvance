---
layout: page
title: leetcode 3170. Lexicographically Minimum String After Removing Stars
permalink: /s3170-java
---
[Leetcode 3170. Lexicographically Minimum String After Removing Stars full problem statement](https://algoadvance.github.io/algoadvance/l3170)
### Problem Statement

You are given a string `s` consisting of lowercase English letters and stars '*' (each representing a backspace operation). You need to remove all stars in the string and return the resulting string such that the stars represent deleting the character immediately before them.

The operation should be processed left to right until all the stars are removed.

Write a function to find the lexicographically minimum string after all star removals. 

**Example:**
```
Input: s = "leet**cod*e"
Output: "lecoe"
```

### Clarifying Questions

1. **Q:** What characters are allowed in the input string?
   **A:** The input string consists of lowercase English letters and '*' characters.

2. **Q:** Can the input string have consecutive '*' characters?
   **A:** Yes, the string can have consecutive '*' characters.

3. **Q:** Are there any size constraints for the input string?
   **A:** The problem does not specify constraints, but we assume it fits within reasonable limits for standard problems, often around 10^5 characters.

### Strategy

Here, our task revolves around simulating the backspacing process. A suitable data structure for this problem is a **Stack** because it allows us to efficiently manage the most recent character, which is the one to be deleted by a '*' operator.

1. **Initialize**: Create an empty stack to store characters.
2. **Iterate** through each character in the input string:
   - If the character is not '*', push it onto the stack.
   - If the character is '*', pop the top character from the stack (if the stack is not empty).
3. **Combine**: Convert the characters in the stack back to a string for the final result.

### Code

```java
public class Solution {
    public String removeStars(String s) {
        Stack<Character> stack = new Stack<>();
        
        for (char c : s.toCharArray()) {
            if (c == '*') {
                if (!stack.isEmpty()) {
                    stack.pop();
                }
            } else {
                stack.push(c);
            }
        }
        
        StringBuilder result = new StringBuilder();
        for (char c : stack) {
            result.append(c);
        }
        
        return result.toString();
    }
}
```

### Time Complexity

- **Time Complexity**: O(n)
  - We need to process each character exactly once.
  - Stack operations (push and pop) are O(1), making the traversal of `n` characters a linear operation.
  
- **Space Complexity**: O(n)
  - In the worst case, none of the characters are '*', so we store all `n` characters in the stack.

This approach is efficient given the problem constraints and ensures that we correctly handle the backspace operations while constructing the lexicographically minimal resultant string.