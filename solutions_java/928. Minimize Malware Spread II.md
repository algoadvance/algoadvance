---
layout: page
title: leetcode 928. Minimize Malware Spread II
permalink: /s928-java
---
[Leetcode 928. Minimize Malware Spread II](https://algoadvance.github.io/algoadvance/l928)
### Problem Statement

You are given a network of `n` nodes represented as an `n x n` adjacency matrix `graph`, where the `i-th` node is directly connected to the `j-th` node if `graph[i][j] == 1`.

Some nodes are initially infected by malware. These nodes are given as an integer array `initial`.

You can remove exactly one node from `initial`. The goal is to minimize the size of the final malware spread. 

Return the node that, if removed, would minimize the spread of the malware. If multiple nodes could be removed to minimize the spread, return the smallest one.

### Clarifying Questions

1. **Are the number of nodes in the network (i.e. `n`) fixed, and is the adjacency matrix square?**
   - Yes, `n` is fixed and the adjacency matrix graph is `n x n`.

2. **Can a node be in the `initial` list more than once?**
   - No, every node in the `initial` list is unique.

3. **If all nodes in initial would result in the same infection size, should we return the smallest index?**
   - Yes, return the smallest node index in such a case.

### Strategy

1. **Graph Representation**: The network is represented as a graph using an adjacency matrix.
2. **Infection Spread**: Understand how malware spreads with DFS/BFS from initially infected nodes.
3. **Effective Removal**: Evaluate the impact of removing each node in the `initial` list and simulate the resulting infection spread.
4. **Choose Optimal Node**: Determine which node's removal results in the minimum spread. In case of a tie, pick the node with the smallest index.

### Code

```java
import java.util.*;

public class MinimizeMalwareSpreadII {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        Set<Integer> initialSet = new HashSet<>();
        for (int node : initial) {
            initialSet.add(node);
        }
        
        int[] infectedBy = new int[n];
        Arrays.fill(infectedBy, -1);
        for (int node : initial) {
            dfs(graph, node, node, infectedBy, new boolean[n]);
        }
        
        int[] count = new int[n];
        for (int node = 0; node < n; node++) {
            if (infectedBy[node] != -1) {
                count[infectedBy[node]]++;
            }
        }
        
        int result = Integer.MAX_VALUE;
        int maxSaved = -1;
        for (int node : initial) {
            int saved = 0;
            for (int neigh = 0; neigh < n; neigh++) {
                if (infectedBy[neigh] == node && count[node] == 1) {
                    saved++;
                }
            }
            if (saved > maxSaved || (saved == maxSaved && node < result)) {
                result = node;
                maxSaved = saved;
            }
        }
        return result;
    }
    
    private void dfs(int[][] graph, int start, int current, int[] infectedBy, boolean[] visited) {
        visited[current] = true;
        if (infectedBy[current] == -1) {
            infectedBy[current] = start;
        } else if (infectedBy[current] != start) {
            infectedBy[current] = -2; // conflicting infections
        }
        for (int nei = 0; nei < graph.length; nei++) {
            if (graph[current][nei] == 1 && !visited[nei]) {
                dfs(graph, start, nei, infectedBy, visited);
            }
        }
    }
}
```

### Strategy Explanation

1. **Identification of Infection**:
   - Use DFS to mark which initial node infects each node in the network.
   
2. **Counting Effective Spread**:
   - Count the number of nodes each initial node can uniquely infect.
   
3. **Determine Node to Remove**:
   - Iterate through each node in `initial` and calculate the potential reduction in infection spread.
   - Keep track of the node which, when removed, results in the maximum reduction.

### Time Complexity

- **DFS Traversal**: Each node in `initial` results in a DFS/BFS traversal of all `n` nodes, making the time complexity in the worst-case scenario `O(n^2 * k)` where `k` is the number of initially infected nodes.
- **Infected Count Calculation**: Another pass through all nodes, contributing `O(n)`.

So the overall time complexity is `O(n^2 * k)`, where `n` is the number of nodes and `k` is the number of initially infected nodes. This should be efficient for typical constraints seen in competitive programming and technical interviews.


### Cut your prep time in half and DOMINATE your interview with [AlgoAdvance AI](https://algoAdvance.com)

- Got blindsided by a question you didn't expect?

- Spend too much time studying?

- Or simply don't have the time to go over all 3000 questions?

