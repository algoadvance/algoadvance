---
layout: page
title: leetcode 1
permalink: /s1-java
---
[Leetcode 1](https://leetcode.com/problems/l1)
### Problem Statement

Given an integer array `nums`, return the number of longest increasing subsequences.

A **subsequence** is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. An **increasing subsequence** is a subsequence that is ordered in increasing order.

### Clarifying Questions

1. **Input constraints:**
   - What is the range of the length of the array `nums`?
   - What are the possible values for the elements in `nums`?

   **Answer:** The length of `nums` can be up to 2000, and the elements in the array can be in the range `[-10^6, 10^6]`.

2. **Output expectations:**
   - Should the function return an integer indicating the count of the longest increasing subsequences?
   
   **Answer:** Yes, the function should return an integer which is the count of the longest increasing subsequences in the array.

3. **Edge cases:**
   - What should be returned if `nums` is empty?
   - Are there any specific edge cases we should handle?

   **Answer:** If `nums` is empty, the function should return 0. We should handle cases with all elements the same and strictly decreasing arrays.

### Strategy

1. **Dynamic Programming Array Setup:**
   - Use two arrays, `lengths` and `counts`.
     - `lengths[i]` will hold the length of the longest increasing subsequence ending at index `i`.
     - `counts[i]` will hold the number of longest increasing subsequences ending at index `i`.

2. **Fill Arrays:**
   - Iterate through `nums` for each possible end index `i`.
   - For each end index `i`, consider all previous indices `j < i` to update `lengths` and `counts` appropriately.
   - Update `lengths[i]` as `max(lengths[i], lengths[j] + 1)` if `nums[j] < nums[i]`.
   - Update `counts[i]` as follows:
     - If `lengths[i] == lengths[j] + 1`, add `counts[j]`.
     - If a new max length sequence is found (`lengths[j] + 1 > lengths[i]`), reset `counts[i]` to `counts[j]`.

3. **Find Result:**
   - The length of the LIS is the maximum value in `lengths`.
   - Sum up all counts corresponding to this maximum length.

### Code

```java
public class Solution {
    public int findNumberOfLIS(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        int n = nums.length;
        int[] lengths = new int[n];
        int[] counts = new int[n];

        Arrays.fill(lengths, 1);
        Arrays.fill(counts, 1);

        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i]) {
                    if (lengths[j] + 1 > lengths[i]) {
                        lengths[i] = lengths[j] + 1;
                        counts[i] = counts[j];
                    } else if (lengths[j] + 1 == lengths[i]) {
                        counts[i] += counts[j];
                    }
                }
            }
        }

        int longest = 0;
        for (int length : lengths) {
            longest = Math.max(longest, length);
        }

        int result = 0;
        for (int i = 0; i < n; i++) {
            if (lengths[i] == longest) {
                result += counts[i];
            }
        }

        return result;
    }
}
```

### Time Complexity

- **Time Complexity:** `O(n^2)` where `n` is the length of the `nums` array. This is because we have two nested loops iterating over the array.
- **Space Complexity:** `O(n)` for the `lengths` and `counts` arrays, where `n` is the length of `nums`.

This implementation is efficient given the constraints, providing a solution within reasonable time and space limits for the problem's input size.