---
layout: page
title: leetcode 924. Minimize Malware Spread
permalink: /s924-js
---
[Leetcode 924. Minimize Malware Spread](https://algoadvance.github.io/algoadvance/l924)
### Problem Statement

In a network of nodes represented as an undirected graph, each node represents a computer and each edge represents a connection between two computers. Some nodes are initially infected by malware.

In this problem, you want to minimize the spread of malware by removing exactly one node. If removing a node results in the minimized number of nodes being infected, return the node with the smallest index. 

The graph is given as an adjacency matrix `graph`, where `graph[i][j] = 1` indicates a connection between nodes `i` and `j, and `graph[i][j] = 0` indicates no connection. Additionally, you are given an array `initial` of initially infected nodes.

Return the node that if removed, would minimize the spread of malware. If multiple nodes result in the same minimized number of infected nodes, return the node with the smallest index.

### Clarifying Questions

1. **Input and Output:**
   - Q: How is the `graph` represented, and what are the constraints?
     - A: The `graph` is an N x N binary matrix (an adjacency matrix), where N is the number of nodes (computers), and `graph[i][j] = 1` indicates that node `i` is connected to node `j`.
   - Q: What is the range of lengths for the `graph` and `initial` array?
     - A: The length of `graph` is between 1 and 300, and the length of `initial` is between 1 and N, which ranges from 1 to 300.

### Strategy

1. **Understand the Graph Connectivity:**
   - Use Union-Find or DFS/BFS to understand connected components in the graph.

2. **Malware Spread Simulation:**
   - Simulate the removal of each node in the `initial` array.
   - Evaluate the size of spread for each scenario.

3. **Optimization Criteria:**
   - Keep track of the node removal yielding the smallest spread.
   - In case of a tie, choose the smallest index node.

### Code Implementation

```javascript
function minMalwareSpread(graph, initial) {
    const N = graph.length;
    
    // Sort initial array to handle smallest index in case of tie.
    initial.sort((a, b) => a - b);
    
    // Helper function to perform DFS and return the size of the connected component.
    const dfs = (node, visited, ignore) => {
        visited[node] = true;
        let size = 1;
        for (let i = 0; i < N; i++) {
            if (i !== ignore && graph[node][i] === 1 && !visited[i]) {
                size += dfs(i, visited, ignore);
            }
        }
        return size;
    }
    
    let minSpread = N;
    let bestNode = initial[0];

    // Try removing each node in the initial list
    for (let i = 0; i < initial.length; i++) {
        const removeNode = initial[i];
        let visited = new Array(N).fill(false);
        let currentSpread = 0;

        // Visit each initially infected node except the one we're 'removing'
        for (let j = 0; j < initial.length; j++) {
            if (initial[j] !== removeNode && !visited[initial[j]]) {
                currentSpread += dfs(initial[j], visited, removeNode);
            }
        }

        // Update the best node and minimum spread
        if (currentSpread < minSpread) {
            minSpread = currentSpread;
            bestNode = removeNode;
        }
    }

    return bestNode;
}
```

### Time Complexity
- **Sorting `initial`:** \( O(k \log k) \), where \( k \) is the number of initially infected nodes.
- **DFS for each node:** \( O(N^2) \) in the worst case for each infection simulation.
- **Overall:** \( O(k \cdot N^2) \)

Given that \( k \) and \( N \) can be at most 300, this complexity is manageable within typical constraints.

This approach ensures we find the node whose removal results in the minimal malware spread and satisfies the problem requirements.


### Cut your prep time in half and DOMINATE your interview with [AlgoAdvance AI](https://algoAdvance.com)

- Got blindsided by a question you didn't expect?

- Spend too much time studying?

- Or simply don't have the time to go over all 3000 questions?

