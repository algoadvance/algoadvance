
---
layout: page
title: leetcode 2019. The Score of Students Solving Math Expression
permalink: /s2019-js
---
[Leetcode 2019. The Score of Students Solving Math Expression](https://algoadvance.github.io/algoadvance/l2019)
## Problem Statement
The problem requires us to evaluate a simple mathematical expression given as a string and determine the number of ways students could achieve any of the potential scores based on incorrect computations. Each student may only make errors by reordering the operations within a particular precedence group and performing integer multiplication and addition straightforwardly. We need to calculate how many unique final scores students could potentially get.

Specifically, the function `scoreOfStudents(expression, answers)` accepts two parameters:
- `expression`: a string representing a mathematical expression consisting of non-negative integers and the operators `+` and `*`. The expression does not contain any parentheses.
- `answers`: an array of integers representing the scores students could give, including potentially incorrect answers.

The function should return the sum of scores each student could get based on possible intermediate values calculated through various incorrect orders of operations.

## Clarifying Questions
1. **Expression Validity**: Can we assume the input expression is always valid and only consists of non-negative integers, `+`, and `*` operators?
2. **Potential Answers**: Should all answers provided be integers, or is there a need to handle invalid (non-integer) values in the `answers` array?
3. **Expression Length and Answer Array Length**: Are there any constraints on the length of the expression or the answers array?

## Strategy
We'll use dynamic programming (DP) to solve this problem, taking advantage of the limited possible ways to rearrange operations in a simple mathematical expression.

### DP Approach:
1. **Evaluate Correct Answer**: First, we compute the correct value of the expression using a straightforward computation.
2. **DP Table Initialization**: Use a DP table where `dp[i][j]` contains all possible results for the sub-expression from index `i` to `j`.
3. **Fill DP Table**: Populate the DP table by evaluating every possible partition of the sub-expression:
   - For each operator at position `k` between `i` and `j`, compute all combinations of results from the left and right sub-expressions and apply the operator.
4. **Validate Possible Scores**: Iterate through the `answers` list and check if each score can be generated by any sub-expression evaluated using the DP table.

### Implementation:

```javascript
var scoreOfStudents = function(expression, answers) {
    const correctAnswer = eval(expression);
    const n = expression.length;

    // Split expression into numbers and operators
    const numbers = [];
    const operators = [];
    for (let i = 0; i < n; i++) {
        if (expression[i] >= '0' && expression[i] <= '9') {
            numbers.push(Number(expression[i]));
        } else {
            operators.push(expression[i]);
        }
    }

    const len = numbers.length;
    const dp = Array.from({length: len}, () => Array.from({length: len}, () => new Set()));

    for (let i = 0; i < len; i++) {
        dp[i][i].add(numbers[i]);
    }

    for (let length = 2; length <= len; length++) {
        for (let i = 0; i <= len - length; i++) {
            const j = i + length - 1;
            for (let k = i; k < j; k++) {
                for (const left of dp[i][k]) {
                    for (const right of dp[k + 1][j]) {
                        if (operators[k] === '+') {
                            dp[i][j].add(left + right);
                        } else {
                            dp[i][j].add(left * right);
                        }
                    }
                }
            }
        }
    }

    // Gather all possible results including the correct answer
    let possibleResults = new Set(dp[0][len - 1]);
    possibleResults.add(correctAnswer);

    let result = 0;

    for (const ans of answers) {
        if (possibleResults.has(ans)) {
            if (ans === correctAnswer) {
                result += 5;
            } else {
                result += 2;
            }
        }
    }
    
    return result;
};
```

### Time Complexity
The time complexity of this approach is O(n^3) where `n` is the number of operators in the expression. This is because we have nested loops for length, starting index, and partition index which all scale with the size of the expression.

### Space Complexity
The space complexity is O(n^2) due to the usage of the DP table to store sets of possible results for every sub-expression.