---
layout: page
title: leetcode 2568. Minimum Impossible OR
permalink: /s2568-js
---
[Leetcode 2568. Minimum Impossible OR](https://algoadvance.github.io/algoadvance/l2568)
### Problem Statement

You are given a 0-indexed integer array `nums`.

We say that an integer x is a bitwise OR-missing if there is no subsequence of `nums` such that the bitwise OR of its elements equals x. Return the minimum bitwise OR-missing number.

A subsequence is a sequence that can be derived from `nums` by deleting some (possibly none) of its elements without changing the order of the remaining elements.

For example, if `nums = [2,1,3]`, the subsequences are:
- `[]`
- `[2]`
- `[1]`
- `[3]`
- `[2,1]`
- `[2,3]`
- `[1,3]`
- `[2,1,3]`

Note: The bitwise OR operator "|" is defined such that for any two integers x and y, x | y is a bitwise OR of x and y.

### Clarifying Questions

1. **Range of `nums` array:**
    - What is the size range of `nums`? 
    - What are the possible integer values in `nums`?

**Assumptions:**
- The size of `nums` can be from `1` up to `10^5`.
- The integers in `nums` can range from `0` up to `2^31 - 1`.

### Strategy

1. **Understanding OR Operator:**
    - The bitwise OR operator results in a number which has a bit set if at least one of the corresponding bits of the operands is set.

2. **Approach:**
    - To determine the minimum number that is not present as a bitwise OR of any subsequence in `nums`, we need to start from the smallest integer (starting from `1`) and check if it can be generated by any combination of OR operations on the elements of `nums`.

3. **Steps:**
    - Use a set to store all the possible OR results from the combinations of the elements in `nums`.
    - Iterate through multiple rounds, each time considering more elements and adding new OR results to the set.
    - Identify the first integer that is missing from the set of OR results.

4. **Optimization Insight:**
    - Since each new OR result can only be created by including new elements, and every integer has a "bit pattern," we can focus on checking the smallest numbers first.

### Code

Here's the implementation of the strategy in JavaScript:

```javascript
var minImpossibleOR = function(nums) {
    const maxNum = Math.max(...nums);
    let reachable = new Set([0]);
    let currSet = new Set([0]);
    
    for (const num of nums) {
        const newSet = new Set();
        for (const val of currSet) {
            newSet.add(val | num);
        }
        
        // Merge newSet into currSet
        for (const val of newSet) {
            currSet.add(val);
        }

        // Merge newSet into reachable
        for (const val of newSet) {
            reachable.add(val);
        }
    }

    let missing = 1;
    while (reachable.has(missing)) {
        missing++;
    }
    
    return missing;
};
```

### Time Complexity

- **Initialization:**
    - Finding the maximum number: `O(n)`, where `n` is the length of the `nums` array.
  
- **Processing OR results:**
    - Each new number in `nums` generates a set of OR computations. In the worst case, if there are `O(k)` elements with distinct bit patterns in `nums`, each addition would result in merging sets. This results in a complexity of approximately `O(n * k)`, where `k` is related to the maximum number of distinct OR results.

- **Space Complexity:**
    - We need additional space to hold the resulting OR computations. Thus, space complexity is approximately `O(k)`.

This approach ensures that we iteratively check for the smallest unreachable integer using bitwise OR combinations.


### Cut your prep time in half and DOMINATE your interview with [AlgoAdvance AI](https://algoAdvance.com)

- Got blindsided by a question you didn't expect?

- Spend too much time studying?

- Or simply don't have the time to go over all 3000 questions?

