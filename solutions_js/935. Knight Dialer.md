---
layout: page
title: leetcode 935. Knight Dialer
permalink: /s935-js
---
[Leetcode 935. Knight Dialer](https://algoadvance.github.io/algoadvance/l935)
Sure, let's dive into solving the problem "935. Knight Dialer".

### Problem Statement

Imagine you have a phone keypad, and you want to count how many distinct phone numbers of length `n` can be created by making valid knight moves. A knight can move in an "L" shape on the keypad. Consequently, the numbers on each valid path must be established by a sequence of such moves. 

The phone keypad is laid out like this:

```
1 2 3
4 5 6
7 8 9
  0
```

The valid moves are:
- From `1` you can move to `6` or `8`.
- From `2` you can move to `7` or `9`.
- From `3` you can move to `4` or `8`.
- From `4` you can move to `3`, `9`, or `0`.
- From `5` you cannot move to any other number.
- From `6` you can move to `1`, `7`, or `0`.
- From `7` you can move to `2` or `6`.
- From `8` you can move to `1` or `3`.
- From `9` you can move to `2` or `4`.
- From `0` you can move to `4` or `6`.

You need to return the number of distinct phone numbers of length `n`.

### Clarifying Questions:
1. Should the phone numbers consider leading zeros? 
    - We'll assume the numbers can start from any key, including `0`.
2. Is there any particular constraint on `n`?
    - Typically the constraints will be around the range of `n`, we'll assume reasonable bounds up to at least `10^4`.

### Strategy

We can apply dynamic programming to solve this problem efficiently. The main idea is to use a DP table where `dp[i][j]` represents the number of distinct numbers of length `i` ending at digit `j`.

Steps:
1. Initialize the DP table with base cases for numbers of length `1`.
2. Use the valid knight moves to fill the table up to the desired length `n`.
3. Sum up the values for all ending digits to get the result.

We'll use modulo `10^9 + 7` to avoid overflow when the result is large.

### Code
Below is the implementation of the described strategy:

```javascript
function knightDialer(n) {
    const MOD = 1e9 + 7;
    const moves = {
        0: [4, 6],
        1: [6, 8],
        2: [7, 9],
        3: [4, 8],
        4: [3, 9, 0],
        5: [],
        6: [1, 7, 0],
        7: [2, 6],
        8: [1, 3],
        9: [2, 4],
    };

    let dp = new Array(10).fill(1);
    dp[5] = 0; // Because 5 can't make any valid move.
    
    for (let i = 1; i < n; i++) {
        const newDp = new Array(10).fill(0);
        
        for (let j = 0; j <= 9; j++) {
            for (const move of moves[j]) {
                newDp[move] = (newDp[move] + dp[j]) % MOD;
            }
        }
        
        dp = newDp;
    }
    
    return dp.reduce((sum, val) => (sum + val) % MOD, 0);
}

// Example usage:
const n = 4;
console.log(knightDialer(n)); // Output the number of distinct n-length phone numbers
```

### Time Complexity

- **Time Complexity:** O(n * 10) = O(n). We iterate over `n` steps, and in each step, we perform constant work (considering 10 digits).
- **Space Complexity:** O(10) = O(1). We use a fixed amount of space for our two DP arrays.

This approach efficiently handles the problem within the expected constraints.