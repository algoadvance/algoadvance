
---
layout: page
title: leetcode 481. Magical String
permalink: /s481-js
---
[Leetcode 481. Magical String](https://algoadvance.github.io/algoadvance/l481)
## Problem Statement

A magical string \( S \) consists of only '1' and '2' and obeys the following rules:

- The string is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string itself.
- The first few elements of the magical string \( S \) is "1221121221221121122...".

Given an integer \( n \), return the number of '1's in the first \( n \) numbers of the magical string \( S \).

**Example 1:**

```
Input: n = 6
Output: 3
Explanation: The first 6 elements of magical string S is "122112" and it contains three 1's, so return 3.
```

**Example 2:**

```
Input: n = 1
Output: 1
```

**Constraints:**

- \( 1 \leq n \leq 10^5 \)

## Clarifying Questions

1. Should the function handle edge cases where \( n = 0 \)?
   - Not necessary as per constraints \(1 \leq n\).
   
2. Are we required to handle invalid inputs?
   - No, assume the input \( n \) is always valid as per the constraints.

3. Is the resultant string likely to be very long? How should we manage memory?
   - Yes, we need to handle up to 100,000 elements. Efficient append and count operations are necessary. 

## Strategy

1. **Initialize the String**: Start with '122'.
2. **Dynamic Generation**: Use two pointers:
   - `i` pointing to the current position for appending '1' or '2'.
   - `j` pointing to the current position in the magical string to decide the count of '1's or '2's to append.
3. **Character Decision**: Alternately append '1' or '2' based on the character at the `j` pointer.
4. **Target Length**: Continue this process until the string's length is at least \( n \).
5. **Count of '1's**: Keep track of the count of '1's during the generation process for efficiency.
6. **Return Result**: Return the count of '1's in the first \( n \) numbers.

## Code

Here is the JavaScript implementation of the strategy:

```javascript
function magicalString(n) {
    if (n <= 0) return 0;
    
    let s = [1, 2, 2];
    let i = 2, j = 2;
    let countOnes = 1;  // Starting with initial '122', there's one '1'
    
    while (s.length < n) {
        let numToAppend = 2 - s[s.length - 1]; // toggles between 1 and 2
        let occurrences = s[j];
        
        for (let k = 0; k < occurrences; k++) {
            s.push(numToAppend);
            if (numToAppend === 1 && s.length <= n) countOnes++;
        }
        j++;
    }
    
    // Restrict `s` to the first `n` elements and count '1's
    return countOnes;
}

// Example Usage
console.log(magicalString(6));  // Output: 3
console.log(magicalString(1));  // Output: 1
```

## Time Complexity

- **Time Complexity**: \(O(n)\). Each element in the magical string will be generated by iterating up to \( n \). The primary operations inside the loop involve simple appends and increment operations, both of which are \(O(1)\).
- **Space Complexity**: \(O(n)\). As we build the magical string, we're storing \( n \) characters, leading to a linear space requirement.