---
layout: page
title: leetcode 2902. Count of Sub
permalink: /s2902-js
---
[Leetcode 2902. Count of Sub](https://algoadvance.github.io/algoadvance/l2902)
### Problem Statement
Given an array of non-negative integers `arr` and an integer `k`, you are to find the number of non-empty sub-multisets of `arr` such that the sum of the elements in each sub-multiset is not greater than `k`.

A sub-multiset of `arr` is defined as any multiset that can be generated by deleting zero or more elements from any possible permutation of `arr`.

### Clarifying Questions
1. **Definition of Sub-Multiset**: Are duplicates allowed in the initial array and subsequently in the sub-multiset?
   - Yes, duplicates are allowed, and a sub-multiset can include multiple instances of an element.
2. **Array Size**: Is there any constraint on the size of the array?
   - The problem did not specify a limit, but for practical purposes, we should assume that the typical constraints apply (1 <= n <= 1000) where `n` is the number of elements in `arr`.
3. **Value Range**: What are the constraints on the values within the array and `k`?
   - Values in the array and `k` are non-negative integers (0 <= arr[i], k <= 1000).

### Strategy
To solve the problem, use a dynamic programming approach which involves:
1. **Dynamic Programming Array**: Use an array `dp` where `dp[j]` represents the number of ways to form sub-multisets with sum `j`.
2. **Initialization**: Initialize `dp[0] = 1` since there is one way to make a sum of `0` â€“ by selecting an empty set.
3. **State Transition**: Update the dp array for each element in `arr`, ensuring that for each possible sum, we add the current element `arr[i]` only if it doesn't exceed the limit `k`.

### Code
```javascript
/**
 * @param {number[]} arr
 * @param {number} k
 * @return {number}
 */
var countOfSubMultisetsWithBoundedSum = function(arr, k) {
    let dp = new Array(k + 1).fill(0);
    dp[0] = 1;
    
    for (let i = 0; i < arr.length; i++) {
        let num = arr[i];
        // We need to iterate from the back to avoid overwriting values we still need.
        for (let j = k; j >= num; j--) {
            dp[j] += dp[j - num];
        }
    }
    
    // Sum up all possibilities of non-zero sub-multisets sums <= k
    let result = 0;
    for (let i = 1; i <= k; i++) {
        result += dp[i];
    }
    
    return result;
};
```

### Time Complexity
1. **Initialization**: `O(k)` to initialize the dp array.
2. **DP Transition**: `O(n*k)` where `n` is the number of elements in the array and `k` is the bound on the sum. Each element updates the dp array in `O(k)` time.
3. **Result Calculation**: `O(k)` to sum up the valid dp entries up to `k`.

Thus, the overall time complexity is `O(n*k)`.

### Space Complexity
The space complexity is `O(k)` for the dp array.


### Cut your prep time in half and DOMINATE your interview with [AlgoAdvance AI](https://algoAdvance.com)

- Got blindsided by a question you didn't expect?

- Spend too much time studying?

- Or simply don't have the time to go over all 3000 questions?

