---
layout: page
title: leetcode 928. Minimize Malware Spread II
permalink: /s928-cpp
---
[Leetcode 928. Minimize Malware Spread II](https://algoadvance.github.io/algoadvance/l928)
### Problem Statement

You are given a network of `n` nodes represented as an `n x n` adjacency matrix `graph`, where the `ith` node is connected to the `jth` node if `graph[i][j] == 1`.

Certain nodes are initially infected by malware. Whenever malware spreads from an infected node `u` to a node `v`, if `v` is not vaccinated (for example, not protected from infection), `v` becomes infected. 

We can remove one infected node entirely to minimize the spread of the malware. What we want to do is to **minimize the final number of infected nodes**. If there are multiple nodes that result in the minimal spread, then return the node index with the smallest index.

Given a list `initial` of already infected nodes (i.e. `initial[i]` is the index of the `i-th` node), return the node index that should be removed.

### Clarifying Questions

1. **Q:** Can nodes be disconnected from the rest of the network?
   - **A:** No, each node is connected directly or indirectly to every other node in a connected network as per the adjacency matrix structure.

2. **Q:** What should we do if the graph has multiple components?
   - **A:** The solution assumes the graph is a single connected component. If there are multiple components, we might need to check if each node results in the minimum spread within its component.

3. **Q:** Is the initial list always non-empty?
   - **A:** Yes, the initial list contains at least one infected node.

### Strategy

1. **Model Spread of Infection:** We will simulate the spread of the infection starting from the initial infected nodes. For each node, we will see how many nodes it infects.

2. **Remove Each Node and Compute Spread:** For each node in the `initial` list, simulate removing that node. Compute how this affects the final number of infected nodes.

3. **Determine Minimum Infection Spread:** Track the minimum number of nodes that get infected by removing each possible initially infected node.

4. **Return Node with Minimum Infection Spread:** If multiple nodes result in the same minimized spread, return the node with the smallest index.

### Code

Here's a concrete implementation in C++:

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>

using namespace std;

void bfs(int start, vector<vector<int>>& graph, vector<bool>& infected, vector<int>& reach) {
    int n = graph.size();
    queue<int> q;
    vector<bool> visited(n, false);
    q.push(start);
    visited[start] = true;

    while (!q.empty()) {
        int node = q.front();
        q.pop();
        if (infected[node]) {
            continue;
        }

        for (int i = 0; i < n; ++i) {
            if (graph[node][i] == 1 && !visited[i]) {
                visited[i] = true;
                q.push(i);
            }
        }
        reach[node]++;
    }
}

int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
    int n = graph.size();
    vector<int> reach(n, 0);
    vector<bool> infected(n, false);
    
    // Mark initial nodes as infected
    for (int node : initial) {
        infected[node] = true;
    }
    
    // Compute reach for each node via BFS
    for (int node : initial) {
        bfs(node, graph, infected, reach);
    }

    int result = -1, maxSaved = -1;

    for (int node : initial) {
        int saved = -reach[node] + 1;  // Nodes saved by removing this infected node (+1 to count all nodes where the BFS did reach)
        if (saved > maxSaved || (saved == maxSaved && node < result)) {
            maxSaved = saved;
            result = node;
        }
    }

    return result;
}

// Example usage
int main() {
    vector<vector<int>> graph = {
        {1, 1, 0},
        {1, 1, 0},
        {0, 0, 1}
    };
    vector<int> initial = {0, 1};
    cout << "Node to remove: " << minMalwareSpread(graph, initial) << endl;  // Output: 0
    return 0;
}
```

### Time Complexity

- **BFS:** Running a BFS from each node takes \(O(n^2)\) where \(n\) is the number of nodes.
- **Total Complexity:** Running BFS from each infected node in the `initial` list means \(O(|initial| \cdot n^2)\). The `|initial|` is typically small compared to `n`, so this should be efficient.

This method ensures correct simulation of malware spread and helps identify the best node to remove to minimize overall infection spread.


### Cut your prep time in half and DOMINATE your interview with [AlgoAdvance AI](https://algoAdvance.com)

- Got blindsided by a question you didn't expect?

- Spend too much time studying?

- Or simply don't have the time to go over all 3000 questions?

