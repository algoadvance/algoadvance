---
layout: page
title: leetcode 935. Knight Dialer
permalink: /s935-cpp
---
[Leetcode 935. Knight Dialer](https://algoadvance.github.io/algoadvance/l935)
### Problem Statement

Given an integer `n`, return the number of distinct phone numbers of length `n` that can be dialed using a standard phone keypad with the constraints of the knight's move in chess. The knight moves in an "L" shape: two squares in one direction and then one square perpendicular to that, or vice versa.

A standard phone keypad layout looks like this:

```
1 2 3
4 5 6
7 8 9
  0
```

Tell how many distinct phone numbers of length `n` can be formed starting from any of the digits 0-9.

Since the answer can be large, return it modulo `10^9 + 7`.

### Clarifying Questions

1. **Can we start dialing from any digit?**
   - Yes, you can start from any digit (0-9).
2. **What is the form of the output?**
   - Return a single integer which is the number of distinct phone numbers of length `n`.

### Strategy

To solve this problem, we can use dynamic programming. We'll maintain a table where each cell represents the count of phone numbers that end in a certain digit after `i` moves.

1. Create a transition matrix to define the valid moves from each digit. For example, from digit `0`, the knight can move to digits `4` and `6`.
2. Use a DP table `dp` where `dp[i][j]` represents the number of distinct phone numbers of length `i` that end with digit `j`.
3. Initialize the table for `n = 1` such that `dp[1][j] = 1` for all digits `j`.
4. Fill in the DP table by considering each previous state and adding possible transitions for the next state.
5. Sum up all the possibilities from the DP table for the final length `n`.

### Code

```cpp
#include <vector>
using namespace std;

class Solution {
public:
    int knightDialer(int n) {
        const int MOD = 1e9 + 7;

        // Define the possible moves for each digit
        vector<vector<int>> moves = {
            {4, 6},     // 0
            {6, 8},     // 1
            {7, 9},     // 2
            {4, 8},     // 3
            {0, 3, 9},  // 4
            { },        // 5 (no valid moves, doesn't affect DP since dp[..][5] will always be 0)
            {0, 1, 7},  // 6
            {2, 6},     // 7
            {1, 3},     // 8
            {2, 4}      // 9
        };

        // Initialize dp array
        vector<vector<long>> dp(n + 1, vector<long>(10, 0));

        // Base case: For length 1, each number is one way to form length 1 phone number
        for (int i = 0; i <= 9; ++i) {
            dp[1][i] = 1;
        }

        // Fill dp table
        for (int i = 2; i <= n; ++i) {
            for (int j = 0; j <= 9; ++j) {
                for (int move : moves[j]) {
                    dp[i][j] = (dp[i][j] + dp[i - 1][move]) % MOD;
                }
            }
        }

        // Sum up all the ways to form length n phone number ending in any digit
        long result = 0;
        for (int j = 0; j <= 9; ++j) {
            result = (result + dp[n][j]) % MOD;
        }

        return result;
    }
};
```

### Time Complexity

- **Time Complexity**: O(n * 10 * 3) = O(n), because for each state (number length), we process each digit (10 digits) and possible moves (up to 3 moves per digit).
- **Space Complexity**: O(n * 10) = O(n), because we maintain a 2D DP table with `n` lengths and 10 digits for each length.

This solution efficiently uses dynamic programming to calculate the number of valid phone numbers of length `n` that can be dialed using knight moves on a phone keypad.


### Cut your prep time in half and DOMINATE your interview with [AlgoAdvance AI](https://algoAdvance.com)

- Got blindsided by a question you didn't expect?

- Spend too much time studying?

- Or simply don't have the time to go over all 3000 questions?

