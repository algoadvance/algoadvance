---
layout: page
title: leetcode 673. Number of Longest Increasing Subsequence
permalink: /s673-cpp
---
[Leetcode 673. Number of Longest Increasing Subsequence](https://algoadvance.github.io/algoadvance/l673)
### Problem Statement

Given an integer array `nums`, return the number of longest increasing subsequences (LIS).

- Example 1:
  ```plaintext
  Input: nums = [1,3,5,4,7]
  Output: 2
  Explanation:
  The two longest increasing subsequences are [1, 3, 4, 7] and [1, 3, 5, 7].
  ```

- Example 2:
  ```plaintext
  Input: nums = [2,2,2,2,2]
  Output: 5
  Explanation:
  The length of the longest increasing subsequence is 1, and there are 5 subsequences of length 1, so output 5.
  ```

### Clarifying Questions

1. **Q**: What are the constraints on the input array `nums`?
   - **A**: The length of `nums` will be in the range [1, 2000]. Each element `nums[i]` is an integer in the range [-10^6, 10^6].

2. **Q**: Can the input array `nums` contain duplicate elements?
   - **A**: Yes, the array can contain duplicates.

3. **Q**: Do we need to return the actual subsequences or just their count?
   - **A**: We only need to return the count of the longest increasing subsequences.

### Strategy

1. **Dynamic Programming Arrays**:
   - Use `length[i]` to store the length of the longest increasing subsequence that ends with `nums[i]`.
   - Use `count[i]` to store the number of longest increasing subsequences that end with `nums[i]`.

2. **Initialization and Iteration**:
   - Initialize `length[i]` to 1 and `count[i]` to 1 for all `i` since the smallest increasing subsequence ending at `nums[i]` is the element itself.
   - Iterate through the array using two nested loops. For each index `i`, compare it to every previous index `j` (where `j < i`).

3. **Updating Lengths and Counts**:
   - If `nums[i] > nums[j]`, then `nums[i]` can extend the increasing subsequence that ends at `nums[j]`.
   - Update `length[i]` and `count[i]` accordingly by either extending the current longest subsequence or counting the new sequences of the same length.

4. **Result Computation**:
   - Identify the maximum value in `length[]`.
   - Sum up the values in `count[]` corresponding to this maximum length to get the total number of longest increasing subsequences.

### Time Complexity

- The solution involves two nested loops through the array, thus the time complexity is `O(n^2)`.
- Space complexity is `O(n)` for maintaining the `length` and `count` arrays.

### Code

```cpp
#include <vector>
#include <algorithm>

class Solution {
public:
    int findNumberOfLIS(std::vector<int>& nums) {
        int n = nums.size();
        std::vector<int> length(n, 1); // length[i] will be the length of LIS ending at index i
        std::vector<int> count(n, 1);  // count[i] will be the number of LISs ending at index i
        
        int maxLength = 0;
        
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < i; ++j) {
                if (nums[i] > nums[j]) {
                    if (length[j] + 1 > length[i]) {
                        length[i] = length[j] + 1;
                        count[i] = count[j];
                    } else if (length[j] + 1 == length[i]) {
                        count[i] += count[j];
                    }
                }
            }
            maxLength = std::max(maxLength, length[i]);
        }

        int numberOfLIS = 0;
        for (int i = 0; i < n; ++i) {
            if (length[i] == maxLength) {
                numberOfLIS += count[i];
            }
        }

        return numberOfLIS;
    }
};
```

This code follows the outlined strategy, leveraging dynamic programming to count the number of longest increasing subsequences efficiently.


### Cut your prep time in half and DOMINATE your interview with [AlgoAdvance AI](https://algoAdvance.com)

- Got blindsided by a question you didn't expect?

- Spend too much time studying?

- Or simply don't have the time to go over all 3000 questions?

