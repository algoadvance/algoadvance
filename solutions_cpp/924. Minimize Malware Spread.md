---
layout: page
title: leetcode 924. Minimize Malware Spread
permalink: /s924-cpp
---
[Leetcode 924. Minimize Malware Spread](https://algoadvance.github.io/algoadvance/l924)
### Problem Statement
In a network of nodes, each node is connected to one or more other nodes. If a node is infected by malware, it can spread to any connected node. The goal is to identify a single node whose removal would minimize the spread of malware, i.e., minimize the number of nodes that ultimately get infected. If there are multiple such nodes, choose the node with the smallest index.

You are given:
- `graph`, a 2D matrix where `graph[i][j] = 1` means node `i` is directly connected to node `j` and `graph[i][j] = 0` means no direct connection.
- `initial`, an array of initially infected nodes.

Return the node which, if removed, minimizes the number of infected nodes. If there is a tie, return the node with the smallest index.

### Clarifying Questions
Before jumping into the solution, let's clarify a few questions:
1. Are all nodes connected in a single connected component?
2. What are the constraints on the size of the graph and the initial list?
3. Is the graph symmetric? (i.e., `graph[i][j] == graph[j][i]`)

### Strategy
To solve this problem, we will:
1. Identify the connected components of the graph.
2. For each node in the initial list, simulate its removal and count the size of the resulting malware spread.
3. Keep track of the node whose removal results in the smallest malware spread.

Here is a more detailed step-by-step approach:
1. Use Depth-First Search (DFS) to identify connected components and their sizes.
2. For each node in the `initial` list, simulate its removal and use DFS/BFS to compute the size of the infection for each component.
3. Keep track of the node whose removal leads to the minimal infection size, resolving ties by choosing the smallest index node.

### Code
```cpp
#include <vector>
#include <unordered_set>
#include <queue>
#include <algorithm>
using namespace std;

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        vector<int> parent(n), size(n, 1);
        iota(parent.begin(), parent.end(), 0);

        function<int(int)> find = [&](int u) {
            return parent[u] == u ? u : parent[u] = find(parent[u]);
        };

        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (graph[i][j] == 1) {
                    int pu = find(i), pv = find(j);
                    if (pu != pv) {
                        if (size[pu] > size[pv]) swap(pu, pv);
                        parent[pu] = pv;
                        size[pv] += size[pu];
                    }
                }
            }
        }

        vector<int> infectedCount(n, 0);
        for (int u : initial) {
            infectedCount[find(u)]++;
        }

        sort(initial.begin(), initial.end());

        int result = initial[0], minSpread = n;
        for (int u : initial) {
            int pu = find(u);
            if (infectedCount[pu] == 1) {
                if (size[pu] < minSpread || (size[pu] == minSpread && u < result)) {
                    result = u;
                    minSpread = size[pu];
                }
            }
        }

        return result;
    }
};
```

### Time Complexity
The major components of the algorithm are:
1. Identifying connected components using Union-Find, which has a time complexity of O(n^2 * α(n)) where α(n) is the inverse Ackermann function.
2. Counting the infected nodes which is O(n).
3. Sorting the initial infected nodes which is O(k log k) where k is the number of initially infected nodes.

In summary, the overall time complexity is roughly O(n^2 log n).

- Union-Find operations: O(n^2 * α(n))
- Sorting initial: O(k log k)

For most practical purposes, this will be efficient enough for typical constraints in competitive programming scenarios.


### Cut your prep time in half and DOMINATE your interview with [AlgoAdvance AI](https://algoAdvance.com)

- Got blindsided by a question you didn't expect?

- Spend too much time studying?

- Or simply don't have the time to go over all 3000 questions?

