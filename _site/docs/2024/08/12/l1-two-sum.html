
<p>layout: posts
title: “Two Sum”
date: 2024-08-12
permalink: /l1-two-sum</p>

<p>Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.</p>

<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>

<p>You can return the answer in any order.</p>

<p> </p>

<p>Example 1:</p>

<p>Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
Example 2:</p>

<p>Input: nums = [3,2,4], target = 6
Output: [1,2]
Example 3:</p>

<p>Input: nums = [3,3], target = 6
Output: [0,1]</p>

<h3 id="clarifying-questions-1-are-all-the-elements-in-the-input-array-distinct---although-we-are-given-that-there-is-exactly-one-solution-this-does-not-necessarily-imply-that-all-elements-are-distinct-the-presence-of-duplicate-numbers-as-in-example-3-should-be-taken-into-account-2-what-should-be-the-behavior-if-the-input-array-is-empty-or-contains-fewer-than-two-elements---since-the-problem-guarantees-exactly-one-solution-we-can-assume-the-input-constraints-allow-for-at-least-two-elements-3-can-the-input-array-contain-negative-numbers---there-is-no-restriction-provided-that-limits-the-values-to-positive-integers-understanding-these-clarifications-ensures-we-design-an-algorithm-that-meets-the-problem-constraints-effectively--strategy-to-solve-this-problem-efficiently-we-can-use-a-hashmap-or-dictionary-in-python-to-store-the-elements-of-the-array-and-their-corresponding-indices-as-we-iterate-through-the-array-1-initialize-an-empty-dictionary-to-keep-track-of-the-numbers-and-their-indices-2-iterate-through-each-element-in-the-array---for-the-current-element-calculate-the-required-complement-that-when-added-to-the-current-element-equals-the-target---check-if-this-complement-is-already-present-in-the-dictionary---if-the-complement-is-found-return-the-indices-of-the-current-element-and-the-complement---if-the-complement-is-not-found-add-the-current-element-along-with-its-index-to-the-dictionary-and-proceed-to-the-next-element">Clarifying Questions 1. <strong>Are all the elements in the input array distinct?</strong> - Although we are given that there is exactly one solution, this does not necessarily imply that all elements are distinct. The presence of duplicate numbers (as in Example 3) should be taken into account. 2. <strong>What should be the behavior if the input array is empty or contains fewer than two elements?</strong> - Since the problem guarantees exactly one solution, we can assume the input constraints allow for at least two elements. 3. <strong>Can the input array contain negative numbers?</strong> - There is no restriction provided that limits the values to positive integers. Understanding these clarifications ensures we design an algorithm that meets the problem constraints effectively. ### Strategy To solve this problem efficiently, we can use a hashmap (or dictionary in Python) to store the elements of the array and their corresponding indices as we iterate through the array. 1. <strong>Initialize an empty dictionary to keep track of the numbers and their indices.</strong> 2. <strong>Iterate through each element in the array.</strong> - For the current element, calculate the required complement that, when added to the current element, equals the target. - Check if this complement is already present in the dictionary. - If the complement is found, return the indices of the current element and the complement. - If the complement is not found, add the current element along with its index to the dictionary and proceed to the next element.</h3>

<h3 id="code">Code</h3>
<p>def two_sum(nums, target): # Dictionary to hold the number and its index num_dict = {} # Iterate over the array for index, num in enumerate(nums): # Determine the needed complement complement = target - num # Check if complement exists in the dictionary if complement in num_dict: # Return the indices of the current number and the complement return [num_dict[complement], index] # Store the number and its index in the dictionary num_dict[num] = index # Test cases print(two_sum([2, 7, 11, 15], 9)) # Output: [0, 1] print(two_sum([3, 2, 4], 6)) # Output: [1, 2] print(two_sum([3, 3], 6)) # Output: [0, 1] “
(string)</p>

<h3 id="time-complexity-the-time-complexity-of-the-above-solution-is-on-where-n-is-the-number-of-elements-in-the-array-this-is-because-we-perform-a-single-traversal-of-the-array-and-dictionary-operations-insert-and-lookup-are-o1-on-average--space-complexity-the-space-complexity-is-also-on-because-in-the-worst-case-we-might-need-to-store-all-n-elements-in-the-dictionary">Time Complexity The time complexity of the above solution is (O(n)), where (n) is the number of elements in the array. This is because we perform a single traversal of the array, and dictionary operations (insert and lookup) are (O(1)) on average. ### Space Complexity The space complexity is also (O(n)) because, in the worst case, we might need to store all (n) elements in the dictionary.”</h3>
