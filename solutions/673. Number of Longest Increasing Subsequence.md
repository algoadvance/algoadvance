---
layout: page
title: Number of Longest increasing subsequence
permalink: /s673
---
### Problem Description

Given an integer array `nums`, return the number of longest increasing subsequences.

### Clarifying Questions

1. **Input Constraints**:
    - What is the range of the size of `nums`? (0 to 2000)
    - What is the range of the integers in `nums`?
    
2. **Output**:
    - Should the solution return the count of longest increasing subsequences or the subsequences themselves? (Count)
    
3. **Edge Cases**:
    - How to handle the case when the input array is empty? (Return 0)
    - How to handle the case when the input has all identical numbers?

Assuming the above constraints and requirements are clear let's move on to the strategy.

### Strategy

1. **Understanding the Problem**:
   - We need to calculate all the longest increasing subsequences in the given array. 
   - This problem is related to the Longest Increasing Subsequence (LIS) problem but with an extra step of counting the number of such sequences.

2. **Approach**:
    We'll use a Dynamic Programming (DP) approach where:
    - `dp[i]` will represent the length of the longest increasing subsequence ending at index `i`.
    - `count[i]` will store the number of longest increasing subsequences ending at index `i`.

   The steps involved:
    1. Iterate through each element in `nums`.
    2. For each element, look at all previous elements to update `dp[i]` and `count[i]`.
    3. Finally, calculate the maximum length of subsequence and sum up counts of sequences which end at this maximum length.

### Code
Here is the Python code to solve the problem:

```python
def findNumberOfLIS(nums):
    if not nums:
        return 0
    
    n = len(nums)
    dp = [1] * n  # Length of LIS ending at index i
    count = [1] * n  # Number of LIS ending at index i
    
    for i in range(n):
        for j in range(i):
            if nums[i] > nums[j]:
                if dp[j] + 1 > dp[i]:
                    dp[i] = dp[j] + 1
                    count[i] = count[j]
                elif dp[j] + 1 == dp[i]:
                    count[i] += count[j]
    
    max_length = max(dp)
    return sum(count[i] for i in range(n) if dp[i] == max_length)


# Example usage
nums = [1, 3, 5, 4, 7]
print(findNumberOfLIS(nums))  # Output: 2
```

### Time Complexity

- **Time Complexity**: `O(n^2)`
  - The two nested loops each iterate through the `n` elements, hence `O(n^2)`.

- **Space Complexity**: `O(n)`
  - The space used by the `dp` and `count` arrays.

This approach ensures that we efficiently calculate both the LIS and the number of such sequences using dynamic programming with a time complexity that should be acceptable for the given constraint (up to 2000 elements).