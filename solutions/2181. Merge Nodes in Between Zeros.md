---
layout: page
title:  Merge Nodes in Between Zeros-out
permalink: /s2181
---
You are given the head of a linked list, which contains a series of integers separated by zeroes. The task is to merge every sequence of non-zero nodes between the zeroes into a single node containing their sum, and return the modified list.

The input linked list will always start and end with a zero.

For example:
```
Input: head = [0,3,1,0,4,5,2,0]
Output: [0,4,11,0]

Explanation:
- The first sequence 3 -> 1 sums to 4.
- The second sequence 4 -> 5 -> 2 sums to 11.
- The list ends with a 0.
```

## Clarifying Questions
1. **What should be returned if the input list has only zeros?**
   - If the list has only zeros, it should return the same list.

2. **What are the constraints on the values inside the linked list?**
   - The constraints are generally given in the problem but assume moderate constraints suitable for interview problems, like up to \(10^5\) nodes.

3. **Is it guaranteed that there will be no consecutive zeros except at the start and end of the list?**
   - Yes, based on the problem description.

## Strategy
1. Initialize a result linked list starting with a zero.
2. Traverse the input list, summing all non-zero values between the zeros.
3. When a zero is encountered (except at the start), append the sum to the result list and reset the sum.
4. Continue until the end of the list.

### Code

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeNodes(head: ListNode) -> ListNode:
    # Creating a dummy node which helps in simplifying edge cases
    dummy = ListNode(0)
    current_new_list = dummy
    
    current = head.next
    sum_intermediary = 0
    
    while current is not None:
        if current.val == 0:
            # Encounters a zero, sum should be added to the new list and reset
            current_new_list.next = ListNode(sum_intermediary)
            current_new_list = current_new_list.next
            sum_intermediary = 0
        else:
            # Add the value to the current sum
            sum_intermediary += current.val
        current = current.next
    
    return dummy.next

# Utility function to create a linked list from list (for testing purposes)
def create_linked_list(arr):
    dummy = ListNode()
    cur = dummy
    for num in arr:
        cur.next = ListNode(num)
        cur = cur.next
    return dummy.next

# Utility function to convert a linked list to a list (for testing purposes)
def linked_list_to_list(node):
    result = []
    while node:
        result.append(node.val)
        node = node.next
    return result

# Example Usage
head = create_linked_list([0, 3, 1, 0, 4, 5, 2, 0])
merged_head = mergeNodes(head)
print(linked_list_to_list(merged_head)) # Output should be [0, 4, 11, 0]
```

### Time Complexity
- **Traversal of the linked list**: O(n), where n is the number of nodes in the linked list.
- The algorithm makes a single pass through the input linked list, and constructs the result linked list in place.
- The space complexity is O(1) excluding the space required for the output linked list as we are using a constant amount of extra space.

This solution efficiently computes the desired result with linear time complexity and constant space complexity apart from the input and output themselves.