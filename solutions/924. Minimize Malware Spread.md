
---
layout: page
title:  Minimize Malware Spread-out
permalink: /s924
---

In a network of nodes, each node is connected to one or more other nodes. We are given an `n x n` adjacency matrix `graph`, where the `j-th` node is connected to the `i-th` node if `graph[i][j] == 1`. Additionally, an array `initial` is provided, which contains indices of initially infected nodes.

Our goal is to minimize the spread of malware. Specifically, we want to remove exactly one node, such that the total number of infected nodes after the removal is minimized. If multiple nodes can achieve the same result, return the smallest index.

**Example:**

```plaintext
Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
Output: 0
```

### Clarifying Questions

1. **Are all the nodes in `initial` guaranteed to be distinct?**
    - Yes, the problem assumes that all initial infected nodes are distinct.
    
2. **Is the graph undirected?**
    - Yes, the graph is undirected, meaning `graph[i][j]` equals `graph[j][i]`.

3. **Are the nodes zero-indexed?**
    - Yes, nodes are zero-indexed as given in the adjacency matrix.

4. **What should be the result if removing any single node does not change the number of infections?**
    - If multiple nodes result in the same minimized spread, choose the node with the smallest index.

### Strategy

1. **Initial Infected Count**: Count the number of infected nodes by considering each connected component without any removals.
2. **DFS/BFS for Connected Components**: Use Depth-First Search (DFS) or Breadth-First Search (BFS) to find the connected components influenced by the initial infected nodes.
3. **Assessment After Removal**: For each node in `initial`, virtually remove it and assess the size of the resultant infection spread.
4. **Comparison and Result**: Track the node whose removal yields the minimum infected nodes and return the smallest index if multiple nodes yield the same results.

### Code

```python
def minMalwareSpread(graph, initial):
    def dfs(node, visited):
        for neighbor in range(len(graph)):
            if graph[node][neighbor] == 1 and neighbor not in visited:
                visited.add(neighbor)
                dfs(neighbor, visited)
    
    n = len(graph)
    
    # Sort the initial list to ensure smallest index preference in ties
    initial.sort()
    
    # Total infected count if no nodes are removed
    total_infected = set(initial)
    visited = set()
    component = {}
    
    # Identify components
    for i in range(n):
        if i not in visited:
            visited.add(i)
            curr_component = set()
            dfs(i, curr_component)
            for node in curr_component:
                component[node] = curr_component
    
    # Function to count unique infections in component by initial nodes
    def unique_infections(component):
        count = [0] * n
        for node in component:
            if node in initial:
                count[node] += 1
        return count
    
    min_infected = float('inf')
    best_node = initial[0]

    for node in initial:
        infected_nodes = set(total_infected)
        infected_nodes.remove(node)
        
        visited = set(infected_nodes)
        new_infected_count = 0
        for i in range(n):
            if i not in visited:
                initial_infected = unique_infections(component[i])
                if sum(initial_infected) == 0:
                    new_infected_count += len(component[i])
                elif sum(initial_infected) == 1 and node in component[i]:
                    continue
                else:
                    new_infected_count += len(component[i])
        
        if new_infected_count < min_infected:
            min_infected = new_infected_count
            best_node = node

    return best_node
```

### Time Complexity

- **Building Components**: \(O(n^2)\) due to DFS/BFS traversal of the graph.
- **Comparison**: \(O(n^2 \cdot m)\) where \(m\) is the size of initial, as we need to assess every node's removal.

Thus, the time complexity is approximately \(O(n^2 \cdot m)\).

This solution provides an efficient method to minimize the number of infected nodes by strategically removing one of the initially infected nodes while maintaining a preference for the smallest index in case of ties.