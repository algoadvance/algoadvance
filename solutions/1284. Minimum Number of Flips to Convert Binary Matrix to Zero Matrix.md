---
layout: page
title:  Minimum Number of Flips to Convert Binary Matrix to Zero Matrix-out
permalink: /s1284
---
Given a `m x n` binary matrix `mat`, you can make a flip operation on a cell. In one flip operation, you flip the cell and all the four neighboring cells (if they exist). A flip operation is defined as turning `1` into `0` and `0` into `1`.

Your goal is to find the minimum number of flip operations needed to convert `mat` to a zero matrix (a matrix with all `0`s). If it is not possible, return `-1`.

### Clarifying Questions:
1. **What are the constraints on `m` and `n`?**
   - Typically, the matrix dimensions are small (e.g., up to 3x3 or 4x4), making brute force or combinatorial approaches feasible.
   
2. **How are neighboring cells defined?**
   - Neighboring cells are the cells directly above, below, to the left, and to the right of the target cell.

3. **Is the matrix guaranteed to be binary (i.e., only `0`s and `1`s)?**
   - Yes, the matrix will only contain `0`s and `1`s.

### Strategy:
We can approach the problem using Breadth-First Search (BFS) because we aim to find the shortest path (minimum number of flips) to reach a specific state (all zeros matrix). BFS is excellent for shortest-path problems in unweighted graphs.

#### Steps:
1. **State Representation**: Represent each state of the matrix as a single tuple for easy comparison and hashing in the BFS.
2. **Flip Operation Implementation**: Create a function to perform the flip operation on a given cell and its neighbors.
3. **BFS Initialization**: Start with the initial matrix and use a queue to explore all possible states generated by flipping each cell.
4. **Goal Check**: Check if a state is the zero matrix, and if so, return the number of flips taken to reach this state.
5. **State Memoization**: Use a set to keep track of visited states to avoid redundant work.

### Code:
```python
from collections import deque

def minFlips(mat):
    def mat2tuple(mat):
        return tuple(tuple(row) for row in mat)
    
    def flip(mat, x, y):
        res = [row[:] for row in mat]
        for i, j in [(x, y), (x-1, y), (x+1, y), (x, y-1), (x, y+1)]:
            if 0 <= i < len(mat) and 0 <= j < len(mat[0]):
                res[i][j] ^= 1
        return res

    m, n = len(mat), len(mat[0])
    initial = mat2tuple(mat)
    zero_matrix = tuple([0] * n for _ in range(m))
    
    if initial == zero_matrix:
        return 0
    
    queue = deque([(initial, 0)])  # (current state, number of flips)
    visited = set([initial])
    
    while queue:
        current, flips = queue.popleft()
        
        for i in range(m):
            for j in range(n):
                new_state = mat2tuple(flip(current, i, j))
                if new_state == zero_matrix:
                    return flips + 1
                if new_state not in visited:
                    visited.add(new_state)
                    queue.append((new_state, flips + 1))
    
    return -1
```

### Time Complexity:
- **State Space**: The number of different states is `2^(m*n)` because each cell can be either `0` or `1`.
- **BFS Traversal**: In the worst case, all states need to be visited. Each state can generate up to 5 new states (1 flip on the chosen cell and its 4 neighbors).
- Time complexity is **O(2^(m*n) * m * n)** considering each state transition involves flipping for all cells and checking/adding states to the queue.

This approach ensures that we find the minimum number of flips to convert the matrix to a zero matrix, if possible.