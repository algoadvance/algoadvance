---
layout: page
title:  Minimize Malware Spread II-out
permalink: /s928
---
You are given a network of `n` nodes represented as an `n x n` adjacency matrix `graph`, where the `i-th` node is connected to the `j-th` node if `graph[i][j] == 1`. Additionally, you are given an array `initial`, where `initial[i]` is the index of a node initially infected by malware. The malware spread happens such that each infected node can spread the malware to its directly connected non-infected nodes in one unit time until no more nodes can be infected.

To minimize the spread of the malware as much as possible, you can remove exactly one node from the initial list. Return the node you should remove to minimize the malware spread. If there are multiple nodes achieving the same result, return the smallest one.

### Clarifying Questions
1. **What is the range of values for `n` and `initial`?**
   - The number of nodes `n` is in the range `[1, 300]`. The length of `initial` is in the range `[1, n]`.

2. **Are the nodes and edges bidirectional?**
   - Yes, the network is represented as an undirected graph.

3. **What should be done when multiple nodes can be removed yielding the same impact?**
   - If multiple nodes result in the same minimized impact, choose the node with the smallest index.

### Strategy
1. **Graph Representation & Input Reading:**
   - The graph is represented as an adjacency matrix. We can use the `graph` to create an adjacency list representation for easier traversal using BFS or DFS.

2. **Simulate Malware Spread:**
   - For each node `v` in `initial`, temporarily remove it from the `initial` list.
   - Perform a BFS or DFS traversal starting from all other nodes in `initial` to determine the extent of malware spread.
   - Calculate the total number of infected nodes if one specific node is removed.

3. **Track and Compare Results:**
   - Keep track of the minimized spread for each removal and choose the node with the smallest index if there are ties.

4. **Edge Cases:**
   - Single node in initial:
     - Simply return that node since it will be the only option.
   - Complete disconnection handling:
     - If removing a node fully disconnects others, this minimizes the spread drastically.

### Code
```python
from collections import deque, defaultdict

def minMalwareSpread(graph, initial):
    def bfs(start, infected):
        queue = deque([start])
        visited = set([start])
        affected = 0
        
        while queue:
            curr = queue.popleft()
            affected += 1
            for neighbor in range(len(graph)):
                if graph[curr][neighbor] == 1 and neighbor not in visited and neighbor not in infected:
                    visited.add(neighbor)
                    queue.append(neighbor)
        
        return affected - 1  # Exclude the start node itself

    n = len(graph)
    initial.sort()  # For tie breaking by smallest index
    min_spread = float('inf')
    best_node = initial[0]

    initial_set = set(initial)
    
    for node in initial:
        infected_set = initial_set - {node}
        spread = 0
        
        for inf in infected_set:
            spread += bfs(inf, infected_set)
        
        if spread < min_spread:
            min_spread = spread
            best_node = node
        elif spread == min_spread and node < best_node:
            best_node = node

    return best_node

# Example Usage:
graph = [[1,1,0],[1,1,0],[0,0,1]]
initial = [0,1]
print(minMalwareSpread(graph, initial))  # Output: 0
```

### Time Complexity
- **Graph Construction:** O(V^2), where V is the number of nodes.
- **BFS for each Removal:** O(V + E), where E is the number of edges. Since this is done for every node in the initial list, worst case O(V * (V + E)).

Thus, for the worst-case scenario:
- The overall time complexity is approximately O(n^3) considering dense graphs with n nodes.


### Try our interview co-pilot at [AlgoAdvance.com](https://algoAdvance.com)

- Got blindsided by a question you didn't expect?

- Spend too much time studying?

- Or simply don't have the time to go over all 3000 questions?

