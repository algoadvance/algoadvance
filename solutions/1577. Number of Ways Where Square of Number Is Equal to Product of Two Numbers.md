---
layout: page
title:  Number of Ways Where Square of Number Is Equal to Product of Two Numbers-out
permalink: /s1577
---

Given two arrays of integers `nums1` and `nums2`, return the number of triplets (i, j, k) such that:

- `nums1[i] * nums1[i] == nums2[j] * nums2[k]` where `0 <= i < nums1.length` and `0 <= j < k < nums2.length`.
- `nums2[j] * nums2[j] == nums1[i] * nums1[k]` where `0 <= j < nums2.length` and `0 <= i < k < nums1.length`.

### Clarifying Questions

1. Can the elements in `nums1` and `nums2` be negative?
   - Yes, the elements can be negative, but we are only concerned with the product, which will always be non-negative.

2. Are there any constraints on the size of the input arrays?
   - Typically, the arrays would be of reasonable size to be processed within a standard interview time frame. Let's assume typical constraints: \(1 \leq \text{length of arrays} \leq 2000\) and \(-10^4 \leq \text{array elements} \leq 10^4\).

3. Are duplicate triplets counted separately?
   - Yes, each valid triplet is counted.

### Strategy

To solve this problem, we need to:

1. **Generate Product Pairs in nums2**: Generate a dictionary to store the frequency of each product \(nums2[j] \times nums2[k]\).
2. **Generate Product Pairs in nums1**: Similarly, create a dictionary for products generated by pairs in `nums1`.
3. **Count Squares in nums1 and nums2**: For each square in `nums1`, check how many times it can be formed using pairs in `nums2`. Similarly, for squares in `nums2`, see how many times they can be formed using pairs in `nums1`.
4. **Iterate and Verify**: Iterate through each number in `nums1` and `nums2`, square it, and use the precomputed product counts to determine the number of valid triplets.

### Code

```python
from collections import defaultdict

def numTriplets(nums1, nums2):
    def get_product_pairs_count(arr):
        product_pairs_count = defaultdict(int)
        n = len(arr)
        for i in range(n):
            for j in range(i + 1, n):
                product_pairs_count[arr[i] * arr[j]] += 1
        return product_pairs_count
    
    def count_valid_triplets(nums1, nums2_product_count):
        count = 0
        for num in nums1:
            target = num * num
            if target in nums2_product_count:
                count += nums2_product_count[target]
        return count
    
    nums2_product_count = get_product_pairs_count(nums2)
    nums1_product_count = get_product_pairs_count(nums1)
    
    count = 0
    count += count_valid_triplets(nums1, nums2_product_count)
    count += count_valid_triplets(nums2, nums1_product_count)
    
    return count
```

### Time Complexity

- **Generating Product Pairs**: O(n^2) for both `nums1` and `nums2`.
- **Counting Valid Triplets**: O(n) for each `nums1` and `nums2`.

Overall time complexity is \(O(n^2 + n^2) = O(n^2)\).

This solution efficiently counts all valid triplets by leveraging the preprocessing counts of product pairs, making it achieve the desired results within the constraints.


### Try our interview co-pilot at [AlgoAdvance.com](https://algoAdvance.com)

- Got blindsided by a question you didn't expect?

- Spend too much time studying?

- Or simply don't have the time to go over all 3000 questions?

