
---
layout: page
title:  Brace Expansion II-out
permalink: /s1096
---

Given a string expression representing multiple sets combined by the brace-expansion rule and concatenation, return all the possible results in any order. 

A brace-expansion rule can be one of the following:

1. If `contains` commas, it represents a union.
2. Otherwise, it represents a sequence concatenation.

More formally, the expression can be described by the following grammar:

1. `{s1,s2,...,sn}` denotes a multiple expression following the union operation.
2. `s1,s2,...,sn` can be concatenated and enclosed by braces `{}`.

### Example 1:
```
Input: "{a,b}{c,d}"
Output: ["ac","ad","bc","bd"]
```

### Example 2:
```
Input: "{{a,z},a{b,c},{ab,z}}"
Output: ["a", "ab", "ac", "z"]
```

### Constraints:
- The expression consists of `{`, `}`, `,`, and lowercase English letters.
- The given expression is valid and can be well-braced.
- Use the following parser rules:
  - Elementary expressions are strings of lowercase English letters.
  - Braced expression stands for recursive parsing of sets of expressions.
  - Expressions that take the form of `a{b,c}` must be treated as concatenations first, before applying unions.

## Clarifying Questions

1. **Depth and complexity constraints**: What's the maximum depth of nested braces we might expect?
2. **Input length**: What is the maximum length of the input string?
3. **Output order**: Is there a specific desired order for the output, or can it be in any lexicographical order?

## Strategy

To solve this problem, we can use a stack-based approach to evaluate the expression:

1. **Token Parsing**:
    - Parse the string token by token using stack data structures.
    - Keep track of union operations using sets and concatenation using Cartesian product operations.

2. **Handling different braces**:
    - Use stacks to handle nested braces.
    - For each encountered `{`, push a new set onto the stack.
    - For `}`, pop from the stack until the corresponding `{` and perform unions and concatenations as per the rules.

3. **Final Combination**:
    - Combine the resulting sets to form the final list.

### Step-by-step Pseudocode

1. Initialize a stack to keep track of the current set being processed.
2. Traverse the string and process characters:
    - When encountering `{`, push a new set on the stack.
    - Process alphabet characters to form elements of sets.
3. Combine sets based on union and concatenation rules.
4. After processing the entire string, the top of the stack contains the result.

## Code

```python
from itertools import product
from collections import deque

def braceExpansionII(expression: str):
    def union(stack):
        union_set = set()
        while stack and stack[-1] != '{':
            union_set.update(stack.pop())
        return union_set

    stack = deque([[]])
    i = 0

    while i < len(expression):
        if expression[i] == '{':
            stack.append('{')
            stack.append(set())
            i += 1
        elif expression[i] == '}':
            union_set = union(stack)
            stack.pop()  # Pop '{'
            stack[-1].append(union_set)
            i += 1
        elif expression[i] == ',':
            union_set = union(stack)
            stack[-1].append(union_set)
            i += 1
        else:
            j = i
            while i < len(expression) and expression[i] not in {'{', '}', ','}:
                i += 1
            element = expression[j:i]
            new_set = {element}
            if type(stack[-1]) == list:
                stack[-1].append(new_set)
            else:
                stack[-1] = stack[-1].union(new_set)

    result_set = union(stack)
    result_list = sorted(result_set)
    return list(result_list)

# Example Usage:
# Test the implementation with provided examples
print(braceExpansionII("{a,b}{c,d}"))    # Output: ["ac", "ad", "bc", "bd"]
print(braceExpansionII("{{a,z},a{b,c},{ab,z}}"))    # Output: ["a", "ab","ac", "z"]
```

## Time Complexity

- **Time Complexity**: Parsing the string expression is O(n), and since we perform union and Cartesian product operations for nested braces, the overall complexity involved in processing these operations can be quite high depending on the number of sets involved.
- **Space Complexity**: O(n) due to the stack memory used for managing nested expressions.

This implementation ensures that the solution adheres to the brace expansion rules and efficiently computes all possible results.