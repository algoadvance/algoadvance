
---
layout: page
title:  Number of Ways to Reorder Array to Get Same BST-out
permalink: /s1569
---

Given an array `nums` that represents a permutation of integers from `1` to `n`. We need to return the number of ways to reorder the array such that the Binary Search Tree (BST) formed using the reordered array is identical to the BST formed from the original array `nums`. Since the answer may be large, it should be returned modulo `10^9 + 7`.

A BST is generated by inserting numbers into an initially empty Binary Search Tree, i.e., the sequence of insertions uniquely determines the structure of the BST.

### Example:
```
Input: nums = [2,1,3]
Output: 1
Explanation: There is only one way to reorder the array which will yield the same BST.
```

```
Input: nums = [3,4,5,1,2]
Output: 5
Explanation: There are 5 ways to reorder the array which will yield the same BST. One possible reordering: [3,1,2,4,5]
```

### Constraints:
- `1 <= nums.length <= 1000`
- `1 <= nums[i] <= nums.length`
- All integers in `nums` are distinct.

## Clarifying Questions

1. **Understanding Nature of BST:** After forming the BST with the initial permutation, do we just care about the structure (shape) of the BST?
   - Yes, the problem mainly revolves around maintaining the shape of the BST when forming with any valid permutation of `nums`.

2. **Modulo Value:** Confirming that the output should be modulo `10^9 + 7`.
   - Yes, the result should be given modulo `10^9 + 7`.

## Strategy

1. **Recursive Approach:** 
   - Split the array into left and right subtrees based on the root (first element of current subarray), and recursively calculate the number of ways for left and right subtree.
   
2. **Combinatorics:**
   - Use combinatorial operations to calculate the ways to combine left and right subarrays preserving their relative order.
     - Specifically, calculate using binomial coefficients (combinations), which can be computed using Pascal's triangle.

3. **Precompute Binomial Coefficients:**
   - To efficiently compute combinations, precompute binomial coefficients up to the maximum needed based on the constraints.

## Code

```python
from math import comb

MOD = 10**9 + 7

def numOfWays(nums):
    def dfs(nums):
        if len(nums) <= 2:
            return 1
        root = nums[0]
        left = [n for n in nums if n < root]
        right = [n for n in nums if n > root]
        left_ways = dfs(left)
        right_ways = dfs(right)
        return comb(len(nums) - 1, len(left)) * left_ways * right_ways % MOD
    
    # The result should exclude the original permutation itself hence we do -1
    return (dfs(nums) - 1) % MOD

# Example usage:
nums1 = [2,1,3]
print(numOfWays(nums1))  # Output: 1

nums2 = [3,4,5,1,2]
print(numOfWays(nums2))  # Output: 5
```

## Time Complexity

1. **Precomputation of Binomial Coefficients:**
   - This can be done in O(n^2) where `n` is the maximum length of the array (1000).

2. **DFS Traversal:**
   - Assuming balanced scenarios, each splitting results in O(log n) splits. Given `n` elements.
   - Thus, the complexity for the recursion, barring combinatorial lookups, is O(n log n).

3. **Overall Complexity:**
   - Considering combinatorial calculations are precomputed, the effective runtime complexity is O(n log n).