
---
layout: page
title:  Count Number of Texts-out
permalink: /s2266
---

You are given a string `pressedKeys` representing the decimal digits each between '2' and '9' each representing a key on a standard phone keypad. The string's length is at most 10^5. We want to count the number of possible valid text messages we could produce by repeatedly pressing these keys. In particular, the valid combinations are determined as follows:
- Each key maps to a set of letters as on a standard mobile phone keyboard as follows:
  - '2' maps to ['a', 'b', 'c']
  - '3' maps to ['d', 'e', 'f']
  - '4' maps to ['g', 'h', 'i']
  - '5' maps to ['j', 'k', 'l']
  - '6' maps to ['m', 'n', 'o']
  - '7' maps to ['p', 'q', 'r', 's']
  - '8' maps to ['t', 'u', 'v']
  - '9' maps to ['w', 'x', 'y', 'z']

A valid text can have all possible letters generated by the given sequence of numbers through valid combinations. The resulting text combinations (from pressing the keys multiple times) should be counted. Since the result may be very large, return it modulo 10^9 + 7.

**Example:**
```
Input: pressedKeys = "22233"
Output: 8
Explanation: There are 8 possible texts: 
"aaadd", "aabdd", "abadd", "baddr", "acdd", "addd", "bzdd", "cddd"
```

## Clarifying Questions

1. Should the function handle only single continuous sequences, or are multiple such sequences possibly interrupted by different digits?
2. Is the order of digits maintained or can we assume any permutation of characters as long as it maintains possible texts?
3. Does the number of repetitions of key-press need to be continuous, isolated per digit, or it can be considered for whole input regardless of digit repetitions?

## Strategy

The strategy involves breaking down the problem into dynamic programming (DP) where we track how many ways we can form valid texts based on the transitions available from each digit:
1. Iterate through the sequence of digits `pressedKeys` and keep track of a DP array where `dp[i]` represents the number of ways to create texts considering the digits up to the `i`-th position.
2. Check for validity by considering combinations up to the maximum sequences each key can represent (3 for most, 4 for digit '7' and '9'). This involves backward checking up to 4 previous indices for valid transitions.
3. Use modulo 10^9 + 7 to ensure results fit within standard integer limits to handle very large outputs.
4. Initialize the first position of `dp` to 1 as the base case.

## Code

```python
MOD = 10**9 + 7

def countTexts(pressedKeys: str) -> int:
    n = len(pressedKeys)
    dp = [0] * (n + 1)
    dp[0] = 1
    
    for i in range(1, n + 1):
        dp[i] = dp[i - 1]
        if i > 1 and pressedKeys[i - 1] == pressedKeys[i - 2]:
            dp[i] = (dp[i] + dp[i - 2]) % MOD
        if i > 2 and pressedKeys[i - 1] == pressedKeys[i - 3] == pressedKeys[i - 2]:
            dp[i] = (dp[i] + dp[i - 3]) % MOD
        if i > 3 and pressedKeys[i - 1] == pressedKeys[i - 4] == pressedKeys[i - 3] == pressedKeys[i - 2] and pressedKeys[i - 1] in "79":
            dp[i] = (dp[i] + dp[i - 4]) % MOD
    
    return dp[n]

# Example usage
pressedKeys = "22233"
print(countTexts(pressedKeys))  # Output: 8
```

## Time Complexity

The time complexity of this solution is \(O(n)\), where \(n\) is the length of the `pressedKeys` string. This is because the solution involves a single pass through the string of pressed keys with constant time operations at each step.

The space complexity is also \(O(n)\) due to the storage required for the `dp` array.

By following this approach, the problem is efficiently handled even for the upper constraint of `pressedKeys` length.